
/*
 * Copyright (c) 2020 Ubique Innovation AG <https://www.ubique.ch>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * SPDX-License-Identifier: MPL-2.0
 */

import DP3TSDK

/// Only CodedError should be used in the UI and UI State
/// All errors that are generated by the SDK or the app should conform to this protocol
protocol CodedError: Error {
    var errorTitle: String? { get }
    var errorCodeString: String? { get }
}

extension DP3TTracingError: LocalizedError, CodedError {
    var errorTitle: String? {
        switch self {
        case let .networkingError(error: wrapped):
            return wrapped.errorTitle
        default:
            return nil
        }
    }

    public var errorDescription: String? {
        let unexpected = "unexpected_error_title".ub_localized
        switch self {
        case let .networkingError(error):
            return error.localizedDescription
        case .caseSynchronizationError, .userAlreadyMarkedAsInfected, .cancelled:
            return unexpected.ub_localized
        case let .databaseError(error):
            return error?.localizedDescription
        case .bluetoothTurnedOff:
            return "bluetooth_turned_off".ub_localized // custom UI, this should never be visible
        case .permissonError:
            return "bluetooth_permission_turned_off".ub_localized // custom UI, this should never be visible
        case let .exposureNotificationError(error: error):
            let nsError = error as NSError
            if nsError.domain == "ENErrorDomain", nsError.code == 4 {
                return "user_cancelled_key_sharing_error".ub_localized
            }
            return error.localizedDescription
        }
    }

    var errorCodeString: String? {
        switch self {
        case let .networkingError(error: error):
            return error.errorCodeString
        case .caseSynchronizationError(errors: _):
            return "ICASYN"
        case .databaseError(error: _):
            return "IDBERR"
        case .bluetoothTurnedOff:
            return "IBLOFF"
        case .cancelled:
            return "ICANCU"
        case .permissonError:
            return "IPERME"
        case .userAlreadyMarkedAsInfected:
            return "IUAMAI"
        case let .exposureNotificationError(error: error):
            let nsError = error as NSError
            return "IEN\(nsError.code)" // Should match code below
        }
    }

    /// We know that Exposure Notification Error with Code 13 is not recoverable
    static let nonRecoverableSyncErrorCode = "IEN13"
}

extension DP3TNetworkingError: LocalizedError, CodedError {
    var errorTitle: String? {
        switch self {
        case .timeInconsistency:
            return "time_inconsistency_title".ub_localized
        default:
            return nil
        }
    }

    public var errorDescription: String? {
        switch self {
        case let .networkSessionError(error: error):
            let nsError = error as NSError
            if nsError.domain == NSURLErrorDomain, nsError.code == -999 {
                return CertificateValidationError.validationFailed.errorDescription
            }
            return "network_error".ub_localized

        case .timeInconsistency:
            return "time_inconsistency_text".ub_localized
        case .notHTTPResponse: fallthrough
        case .HTTPFailureResponse: fallthrough
        case .noDataReturned: fallthrough
        case .couldNotParseData: fallthrough
        case .couldNotEncodeBody: fallthrough
        case .batchReleaseTimeMissmatch: fallthrough
        case .jwtSignatureError:
            return "unexpected_error_title".ub_localized
        }
    }

    var errorCodeString: String? {
        switch self {
        case let .networkSessionError(error: error):
            let nsError = error as NSError
            return "INET\(nsError.code)"
        case .notHTTPResponse:
            return "INORES"
        case let .HTTPFailureResponse(status: status):
            return "IRST\(status)"
        case .noDataReturned:
            return "INODAT"
        case .couldNotParseData(error: _, origin: _):
            return "IPARS"
        case .couldNotEncodeBody:
            return "IBODEN"
        case .batchReleaseTimeMissmatch:
            return "IBRTMM"
        case .timeInconsistency(shift: _):
            return "ITIMIN"
        case let .jwtSignatureError(code: code, debugDescription: _):
            return "IJWTSE\(code)"
        }
    }
}

extension NetworkError: LocalizedError, CodedError {
    var errorTitle: String? {
        nil
    }

    var errorDescription: String? {
        switch self {
        case .networkError:
            return "network_error".ub_localized
        case .statusError(code: _): fallthrough
        case .parseError: fallthrough
        case .unexpected(error: _):
            return "unexpected_error_title".ub_localized
        }
    }

    var errorCodeString: String? {
        switch self {
        case .networkError:
            return "ICNETE"
        case let .statusError(code: code):
            return "IBST\(code)"
        case .parseError:
            return "ICPARS"
        case let .unexpected(error: error):
            let nsError = error as NSError
            return "IUNXN\(nsError.code)"
        }
    }
}

/// Swift does not (yet) allow to specify what kind off error is thrown
/// Since we only want to pass CodedErrors through the app
/// We wrap everything that should not happen
enum UnexpectedThrownError: LocalizedError, CodedError {
    var errorTitle: String? {
        nil
    }

    case startTracing(error: Error)

    var errorDescription: String? {
        return "unexpected_error_title".ub_localized
    }

    var errorCodeString: String? {
        switch self {
        case let .startTracing(error):
            let nsError = error as NSError
            return "IUSTE\(nsError.code)"
        }
    }
}

extension CertificateValidationError: LocalizedError, CodedError {
    var errorTitle: String? {
        nil
    }

    var errorDescription: String? {
        return "certificate_validation_error".ub_localized
    }

    var errorCodeString: String? {
        return "ICERT"
    }
}
